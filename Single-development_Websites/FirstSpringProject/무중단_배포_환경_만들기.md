# 무중단 배포 환경 만들기
#### 배포해도 서비스가 종료 되지않는 환경을 만든다.

---
### 현재 문제점
* 젠킨스를 이용해  배포 자동화 환경을 구축 했다.
* 하지만, 배포하는 동안 어플리케이션이 종료된다.
* 24시간 서비스되는 어플리케이션은 서비스가 중지되면 안된다.

### 무중단 배포 방식들
* AWS의 블루 그린 무중단 배포
* 도커를 이용한 웹서비스 무중단 배포
* L4 스위치를 이용한 방법
* Nginx를 이용한 방법
* 여기서는 Nginx의 리버스 프록시를 이용해 무중단 배포를 진행한다.

### 무중단 배포 과정
* 서버에서 Nginx에 스프링 부트 어플리케이션 2개를 구동 시킨다.
* 8081 포트 에서 실행되는 스프링 부트, 8082 포트에서 실행되는 스프링 부트가 있다 가정하자.
* Nginx를 사용하기 때문에 클라이언트는 80포트나 443포트로 접속한다.
* Nginx는 리버스 프록시를 이용해 내부의 8081이나 8082포트로 요청을 전달한다.
* 즉, 이를 이용해 무중단 배포는 다음과 같이 이루어 진다.
> 1. 배포 시작시 8082가 정상 구동중인지 확인 한다.
> 2. 정상 구동 중이라면 nginx가 8082를 바라 보게한다.(이 과정은 0.1초 이내에 완료 된다.)
> 3. 8081에 배포를 한다.
> 4. 배포가 완료 되면 다시 8081을 바라 보게 한다.
* 위와 같이 구성되면 무중단 배포 시스템 전체 구조는 아래와 같다.
  
![이미지](https://raw.githubusercontent.com/ccc96360/ccc96360/main/images/studyspring/%EB%AC%B4%EC%A4%91%EB%8B%A8%20%EB%B0%B0%ED%8F%AC/%EB%AC%B4%EC%A4%91%EB%8B%A8%EB%B0%B0%ED%8F%AC_%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8.png)
  

---
## 1. Nginx 설치와 스프링 부트 연동하기
### 1.1 Nginx 설치
```shell
apt-get install nginx
```
* 위 명령어로 설치 해준다.
```shell
service nginx start
netstat -lntp
```
* 위명령어로 nginx를 실행 하고 80번 포트가 리스닝 되고있는지 확인한다.
* 웹에서 80번 포트로 접근해 다음과 같은 화면이 출력 되면 성공이다.
  
![이미지](https://raw.githubusercontent.com/ccc96360/ccc96360/main/images/studyspring/%EB%AC%B4%EC%A4%91%EB%8B%A8%20%EB%B0%B0%ED%8F%AC/%EC%97%94%EC%A7%84%EC%97%91%EC%8A%A4%20%EC%B4%88%EA%B8%B0%ED%99%94%EB%A9%B4.PNG)
  
## 1.2 Nginx와 Spring Boot 연동하기
* ```/etc/nginx/sites-available```에 아래와 같이 작성한다.
```conf
server{
    listen		80 default_server;
    listen		[::]:80 default_server;
    server_name localhost;
    root 		/usr/share/nginx/html;

    location / {
        proxy_pass http://localhost:8080;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Host $http_host;
    }
}
```
* 스프링 부트가 서비스 되는 8080포트로 리버스 프록시 설정을 하는 것이다.

---
## 2. 무중단 배포 스크립트 만들기

### 2.1 profile API추가
* Profile Controller를 만들어 다음과 같은 API를 추가한다.
* 배포시 어떤 포트를 사용할지를 판단하는 기준이 된다. 
```java
@RequiredArgsConstructor
@RestController
public class ProfileController {
    private final Environment env;
    
    @GetMapping("/profile")
    public String profile(){
        List<String> profiles = Arrays.asList(env.getActiveProfiles());
        List<String> realProfiles = Arrays.asList("real", "real1", "real2");
        String defaultProfile = profiles.isEmpty()? "default" : profiles.get(0);
        
        return profiles.stream().filter(realProfiles::contains).findAny().orElse(defaultProfile);
    }
}
```
* env.getActiveProfiles()를 통해 현재 실행중인 Profile을 모두 가져온다.

### 2.2 Profile API Test
* 스프링 환경이 필요하지 않으므로 @SpringBootTest없이 진행한다.
```java
package com.devminj.web;

import javafx.beans.binding.When;
import org.junit.Test;
import org.springframework.mock.env.MockEnvironment;

import static org.assertj.core.api.Assertions.assertThat;

public class PrifleControllerUnitTest {

    @Test
    public void real_profile이_조회된다(){
        //Given
        String expectedProfile = "real";
        MockEnvironment env = new MockEnvironment();
        env.addActiveProfile(expectedProfile);
        env.addActiveProfile("oauth");
        env.addActiveProfile("real-db");

        ProfileController controller = new ProfileController(env);
        //When
        String profile = controller.profile();
        //Then
        assertThat(profile).isEqualTo(expectedProfile);
    }

    @Test
    public void real_profile이_없으면_첫_번째가_조회된다(){
        //Given
        String expectedProfile = "oauth";
        MockEnvironment env = new MockEnvironment();
        env.addActiveProfile(expectedProfile);
        env.addActiveProfile("real-db");

        ProfileController controller = new ProfileController(env);
        //When
        String profile = controller.profile();
        //Then
        assertThat(profile).isEqualTo(expectedProfile);
    }

    @Test
    public void active_profile_이_없으면_default가_조회된다(){
        //Given
        String expectedProfile = "default";
        MockEnvironment env = new MockEnvironment();
        ProfileController controller = new ProfileController(env);
        //When
        String profile = controller.profile();
        //Then
        assertThat(profile).isEqualTo(expectedProfile);
    }
}
```
### 2.3 SecurityConfig 설정 변경
```java
.antMatchers("/","/css/**","images/**","/js/**","/h2-console","/profile").permitAll()
```
* 마지막에 /profile을 추가해 준다.

### 2.4 테스트
* 스프링 시큐리티 설정을 불러와야 하므로 @SpringBootTest를 사용하는 테스트 클래스를 아래와 같이 하나 더 만든다
```java
@RequiredArgsConstructor
@RestController
public class ProfileController {
    private final Environment env;

    @GetMapping("/profile")
    public String profile(){
        List<String> profiles = Arrays.asList(env.getActiveProfiles());
        List<String> realProfiles = Arrays.asList("real", "real1", "real2");
        String defaultProfile = profiles.isEmpty()? "default" : profiles.get(0);

        return profiles.stream().filter(realProfiles::contains).findAny().orElse(defaultProfile);
    }
}
```
* 테스트가 통과되면 깃에 푸시해서 배포해 확인 해 본다.
> ......../dto/OAuthAttributes.java uses unchecked or unsafe operations.
* 위와 같은 에러가 나가서 [구글 클라우드 플랫폼](https://console.cloud.google.com/?pli=1) ,  [네이버 오픈 API](https://developers.naver.com/apps/#/register?api=nvlogin) 에서 엔진엑스 포트를 리다이렉션 URI에 추가했다.