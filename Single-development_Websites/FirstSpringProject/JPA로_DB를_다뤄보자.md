[이전으로](../Readme.md)
# JPA로 DB를 다뤄보자
#### JPA를 이용해 게시판 CRUD를 구현해 본다.

---
## SQL 매퍼 vs ORM(Object Relational Mapping)
* SQL매퍼: 쿼리를 매핑, ```MyBatis``` 가 있다.
* ORM: 객체를 매핑, ```JPA```가 있다.
* JPA는 Java ORM 표준이다.

---
## 1. JPA
* 웹 어플리케이션에서 객체를 관계형 데이터베이스에서 관리 하는것은 중요하다.
* 결국 서비스의 중심이 DB가 되면서 프로젝트의 대부분이 SQL로 가득해졌다.
* 개발자가 아무리 클래스를 아름 답게 설계해도, SQL을 통해야만 DB에 저장하고 조회할 수 있다.
### 1.1 기존의 문제점
* 수십, 수백 개의 테이블의 몇배의 SQL을 만들고 유지 보수 해야한다.
* ```패러다임 불일치``` 문제가 있다.
> #### 패러다임 불일치
> 관계형 DB는 ```어떻게 데이터를 저장할지```에 초점이 맞춰진 기술이다.
> 하지만, OOP는 메시지를 기반으로 ```기능과 속성을 한 곳에서 관리```하는 기술이다.
> 즉, 관계형DB와 OOP 언어의 패러다임이 서로 다른데 객체를 DB에 저장하려 하니 문제가 발생 하는 것이다.

* 다음 예시를 살펴보자.
```java
User user = findUser();
Group group = uesr.getGroup();
```
* 위 코드는 누구나 명확하게 ```User```와 ```Group```이 부모-자식 관계임을 알 수 있다.
* 하지만 DB가 추가 되면 다음과 같이 변경된다.
```java
User user = userDao.findUser();
Group group = groupDao.findGroup(user.getGroupId());
```
* ```User``` 따로 ```Group``` 따로 조회하게 된다.
* 상속, 1:N 등 다양한 객체 모델링을 DB로는 구현할 수 없기 때문에 DB 모델링에만 집중하게 된다.
* ```JPA```는 이러한 문제점을 해결하기 위해 등장한다.
### 1.2 JPA란?
* 서로 지향하는 바가 다른 2개 영역(OOP언어와 RDB)을 중간에서 패러다임 일치를 시켜주기 위한 기술이다.
* 즉, 개발자는 `객체지향적`으로 프로그래밍을 하고, JPA가 이를 DB에 맞게 SQL을 대신 생성해서 실행한다.
* 따라서 더는 SQL에 종속적인 개발을 하지 않아도 된다. 결국 생산성이 향상되고 유지보수도 쉬워진다.

### 1.3 Spring Data JPA
* 인터페이스인 JPA를 사용하기 위해서는 구현체가 필요하다. 대표적으로 ```Hibernate```, ```EclipseLink```가 있다.
* 하지만 Spring에서 JPA를 사용할 때는 이 구현체들을 직접 다루진 않는다.
* 구현체들을 좀 더 쉽게 사용하고자 추상화 시킨 Spring Data JPA라는 모듈을 이용해 JPA 기술을 다룬다.
> 관계: JPA <- Hibernate <- Spring Data JPA 
* 한단계 더 감싸놓은 Spring Data JPA와 Hibernate를 쓰는 것 아이네느 큰 차이가 없지만, 그럼에도 사용 하는 이유는 크게 2가지 이다.
> #### 구현체 교체의 용이성
> * ```Hibernate```외에 ```다른 구현체로 쉽게 교체하기 위함```이다.
> * Spring Data JPA 내부에서 구현체 매핑을 지원해주기 떄문이다.
 
> #### 저장소 교체의 용이성
> * RDB외에 다른 저장소로 쉽게 교체하기 위함이다.
> * 만약 MongoDB로 교체가 필요하다면 개발자는 Spring Data JPA를 Spring Data MongoDB로 의존성만 교체하면 된다.
> * Spring Data의 하위 프로젝트의 기본적인 CRUD 인터페이스가 같기 떄문에 가능한 일이다.

---
## 2. Spring Data JPA 적용하기
### 2.1 의존성 추가
```gradle
    compile('org.springframework.boot:spring-boot-starter-data-jpa:')
    compile('com.h2database:h2')
```
* 위와같이 build.gradle에 의존성을 추가한다.

### 2.2 domain 패키지 추가
* domain패키지를 추가한다.
* 내부에 posts 패키지와 아래와 같이 ```Posts``` 클래스를 생성한다.
```java
@Getter
@NoArgsConstructor
@Entity // Table과 링크될 클래스이다. 카멜케이스 이름을 언더스코어 네이밍(스네이크 케이스)으로 매칭한다.
public class Posts {

    @Id // PK이다.
    @GeneratedValue(strategy = GenerationType.IDENTITY) // PK 생성규칙, Auto Increment가 적용된다.
    private Long id;

    // 디폴트 값외에 추가로 변경하고 싶은 옵션이 있을때 사용, 없어도 테이블의 컬럼이다.
    // String의 columnDefinition의 디폴트 값은 VarChar(255)이다.
    @Column(length = 500, nullable = false)
    private String title;
    
    @Column(columnDefinition = "TEXT", nullable = false)
    private String content;

    //@Column이 없어도  클래스의 필드는 어트리 뷰트이다.
    private String author;

    @Builder
    public Posts(String title, String content, String author){
        this.title = title;
        this.content = content;
        this.author = author;
    }
}
```
* Entitiy 클래스 에서는 Setter 메서드를 만들지 않는다. 
* 대신, 해당 필드의 값이 변경이 필요하면 명확이 그 목적과 의도를 나타낼 수 있는 메서드를 추가 해야한다.
```java
// 잘못된 예시
public class Order(){
    public void setStatus(boolean status){
        this.status = status
    }
}
public void 주문서비스의_취소이벤트(){
    order.setStatus(false);
}

//올바른 예시
public class Order(){
    public void cancelOrder(){
        this.status = false;
    }
}
public void 주문서비스의_취소이벤트(){
    order.cancelOrder();
}
```
### 2.3 Repository 추가
* 위에서 만든 Posts 클래스로 DB를 접근하게 해줄 JpaRepository를 생성한다.
* Posts 클래스와 같은 패키지 내부에 아래와 같은 Repository 인터페이스를 추가한다.
```java
public interface PostsRepository extends JpaRepository<Posts, Long> {
    
}
```
* ```MyBatis```에서 Dao라 불리는 DB Layer 접근자이다.
* 인터페이스 생성후 JpaRepository<Entity클래스, PK타입>을 상속하면 기본적인 CRUD 메소드가 자동으로 생성된다.


### 2.4 테스트
* 아래와 같은 테스트 코드를 작성한다.
```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class PostsRepositoryTest {

    @Autowired
    PostsRepository postsRepository;

    @After
    public void cleanup(){
        postsRepository.deleteAll();
    }

    @Test
    public void 게시글저장_불러오기(){
        //given
        String title = "테스트 게시글";
        String content = " 테스트 본문";

        // insert/update 쿼리가 실행된다.
        // id 값이 있다면 update가, 없다면 insert쿼리가 실행된다.
        postsRepository.save(Posts.builder().title(title).content(content).author("DevMinJ").build());
        //when
        List<Posts> postsList = postsRepository.findAll();
        //then
        Posts posts = postsList.get(0);
        Assertions.assertThat(posts.getTitle()).isEqualTo(title);
        Assertions.assertThat(posts.getContent()).isEqualTo(content);
    }
}
```
* 실제로 실행된 쿼리는 어떤 형태인지 보는법 
* /src/main/resources에 application.properties 생성
```
spring.jpa.properties.hibernate.show_sql=true
```
* ```application.properties```에 위와 같이 추가하면 아래와 같이 나오는 것을 볼 수 있다.
```aidl
Hibernate: drop table posts if exists
Hibernate: create table posts (id bigint generated by default as identity, author varchar(255), content TEXT not null, title varchar(500) not null, primary key (id))
...
...
Hibernate: delete from posts where id=?
Hibernate: drop table posts if exists
```
* 아래한줄을 추가해주면 이쁘게 출력 된다.
```aidl
spring.jpa.properties.hibernate.format_sql=true
```
* 이런식으로
```aidl
    create table posts (
       id bigint generated by default as identity,
        author varchar(255),
        content TEXT not null,
        title varchar(500) not null,
        primary key (id)
    )
    Hibernate: 
    insert 
    into
        posts
        (id, author, content, title) 
    values
        (null, ?, ?, ?)
```
* 그런데 ```create table```쿼리에서  ```id bigint generated by default as identity```라는 옵션으로 생성된다.
* 이는 H2의 쿼리 문법이 적용 되었기 때문이다.
* 디버깅을 위해 출력되는 쿼리 로그를 MySQL 버전으로 변경한다.
```aidl
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect
```
* application.properties에 위 설정을 추가한다.
* 아래와 같이 출력이 변경된 것을 볼 수 있다.
```aidl
    create table posts (
       id bigint not null auto_increment,
       ...
```

---
## 3. 등록/수정/조회 API만들기
* API를 만들기 위해 다음과 같은 3개의 클래스가 필요하다.
> Request 데이터를 받을 ```Dto```, API 요청을 받을 ```Controller```, 트랜잭션, 도메인 기능 간의 순서를 보장하는 ```Service```
* ```Service```는 트랜잭션, 도메인 간 순서 보장의 역할만 할 뿐, 비지니스 로직을 처리해야한다는 것은 오해이다.
* 비지니스 로직은 Spring 웹 계층중 ```Domain Model```에서 처리해야한다.
* 기존의 서비스로 처리하던 방식을 ```트랜잭션 스크립트```라고 한다. 아래와 같이 작성한다.
```java
@Transactional
public Order cancelOrder(int orderId){
    OrderDto order = ordersDao.selectOrders(orderId);
    BillingDto billing ...생략...
    DeliveryDto delivery ...생략...
        
    String deliveryStatus = delivery.getSatus();
    
    if(deliveryStatus.equals("IN_PROGRESS")){
        delivery.setStatus(...)
        deliveryDao.update(delivery)    
    }
    
    order.setStatus(...)
    orderDao.update(order)
        
    billing.setStatus(...)
    billingDao.update(billing)
        
    return order;
}
```
* 위 코드는 모든 로직이 서비스 클래스 내부에서 처리된다.
* 따라서 ```서비스 계층```이 무의미해진다.
* 반면 도메인 모델에서 처리할 경우 다음과 같은 코드가 될 수 있다.
```java
@Transactional
public Order cancelOrder(int orderId){
    Orders order = ordersRepository.findById(orderId);
    Billing billing = billingRepository.findById(orderId);
    Delivery delivery = ...
    
    delivery.cancel();
    order.cancel();
    billing.cancel();
    
    return order;
}
```
* ```order```, ```billing```, ```delivery```가 각자 본인의 취소 이벤트 처리를 하며, 서비스 메소드는 트랜잭션과 도메인 간의 순서만 보장한다.
### 3.1 등록 기능 추가
* ```PostsApiController```, ```PostSaveRequestDto```, ```PostsService```를 추가 한다.
```java
// /web/PostsApiController
@RequiredArgsConstructor// final이 선언된 모든 필드를 인자값으로 하는 생성자를 만든다
                        // 이때 Bean을 주입 받는다. 
@RestController
public class PostsApiController {
    private final PostsService postsService;

    @PostMapping("/api/v1/posts")
    public Long save(@RequestBody PostsSaveRequestDto requestDto){
        return postsService.save(requestDto);
    }
}
```
```java
// /web/dto/PostsSaveRequestDto
@Getter
@NoArgsConstructor
public class PostsSaveRequestDto {
    private String title;
    private String content;
    private String author;

    @Builder
    public PostsSaveRequestDto(String title, String content, String author){
        this.author = author;
        this.content = content;
        this.title = title;
    }

    public Posts toEntity(){
        return Posts.builder()
                .title(title)
                .author(author)
                .content(content)
                .build();
    }
}
```

```java
// /service/posts/PostsService
@RequiredArgsConstructor
@Service
public class PostsService {
    private final PostsRepository postsRepository;

    @Transactional
    public Long save(PostsSaveRequestDto requestDto){
        return postsRepository.save(requestDto.toEntity()).getId();
    }
}
```
### 3.2 테스트
* 다음과 같은 테스트 코드를 작성한다.
```java
@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class PostsApiControllerTest {

    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate restTemplate;

    @Autowired
    private PostsRepository postsRepository;

    @After
    public void tearDown() throws Exception{
        postsRepository.deleteAll();
    }

    @Test
    public void Posts_등록된다() throws Exception{
        // given
        String title = "title";
        String content = "content";

        PostsSaveRequestDto requestDto = PostsSaveRequestDto.builder()
                .title(title)
                .content(content)
                .author("author")
                .build();

        String url = "http://localhost:" + port + "/api/v1/posts";
        // when
        ResponseEntity<Long> responseEntity = restTemplate.postForEntity(url, requestDto, Long.class);
        // then

        assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(responseEntity.getBody()).isGreaterThan(0L);

        List<Posts> all = postsRepository.findAll();
        assertThat(all.get(0).getTitle()).isEqualTo(title);
        assertThat(all.get(0).getContent()).isEqualTo(content);
    }
}
```
* HelloController 테스트와 달리 ```@WebMvcTest```를 사용하지 않았다.
* ```@WebMvcTest```를 사용하면 JPA 기능이 작동하지 않기 때문이다.
### 3.3 수정/조회 기능 추가
* 기능 추가를 위해 ```PostsApiController```에 API를 추가 한다.
```java
public class PostsApiController {
    ...
    @PutMapping("/api/v1/posts/{id}")
    public Long update(@PathVariable Long id, @RequestBody PostsUpdateRequestDto requestDto){
        return postsService.update(id, requestDto);
    }

    @GetMapping("/api/v1/posts/{id}")
    public PostsResponseDto findById(@PathVariable Long id){
        return postsService.findById(id);
    }

}
```
* ```PostsResponseDto``` 와 ```PostsUpdateDto```를 다음과 같이 추가한다
```java
@Getter
public class PostsResponseDto {
    private Long id;
    private String title;
    private String content;
    private String author;

    public PostsResponseDto(Posts entity){
        this.id = entity.getId();
        this.title = entity.getTitle();
        this.content = entity.getContent();
        this.author = entity.getAuthor();
    }
}
@Getter
@NoArgsConstructor
public class PostsUpdateRequestDto {
    private String title;
    private String content;

    @Builder
    public PostsUpdateRequestDto(String title, String content){
        this.title = title;
        this.content = content;
    }
}
```
* ```PostsService```에 서비스를 추가하고 ```Posts```엔티티 클래스에 업데이트르 위한 메서드를 추가한다.
```java
public class PostsService {
    ... ...
    
    @Transactional
    public Long update(Long id, PostsUpdateRequestDto requestDto){
        Posts posts = postsRepository.findById(id).orElseThrow(() -> new
                IllegalArgumentException("해당 게시글이 없습니다. id ="+ id)
        );
        posts.update(requestDto.getTitle(), requestDto.getContent());

        return id;
    }

    public PostsResponseDto findById(Long id){
        Posts entity = postsRepository.findById(id).orElseThrow(() -> new IllegalArgumentException("해당 게시글이 없습니다. id = " + id));
        return new PostsResponseDto(entity); 
    }
}

public class Posts {
    ... ...
    
    public void update(String title, String content){
        this.title = title;
        this.content = content;
    }
}
```
* 이때, ```PostsService```의 update에서 수정된 내용을 DB에 반영하는 쿼리를 날리는 부분이 없다.
* 쿼리 없음에도 불구하고 DB가 업데이트 되는이유는 JPA의 ```영속성 컨텍스트``` 때문이다.
* ```영속성 컨텍스트```란, 엔티티를 영구 저장하는 환경이다.
* JPA의 엔티티 매니저가 활성화 된 상태로(Spring Data Jpa 를 쓴다면 기본 옵션) 트랜잭션 안에서 DB의 데이터를 가져오면 이 데이터는 ```영속성 컨텍스트```가 유지된 상태이다.
* ```영속성 컨텍스트``` 가 유지된 상태에서 값을 변경하면 트랜잭션이 끝나느 시점에 헤당 테이블에 변경분을 반영한다.
* 이 개념을 [더티 체킹](https://jojoldu.tistory.com/415) 이라고한다

### 3.4 테스트
* 수정 기능 테스트를 위해 다음코드를 ```PostsApiControllerTest```에 추가한다.
```java
    @Test
    public void Posts_수정된다() throws Exception{
        //given
        Posts savedPosts = postsRepository.save(Posts.builder()
            .title("title")
                .content("content")
                .author("author")
                .build()
        );
        Long updateId = savedPosts.getId();
        String expectedTitle = "title2";
        String expectedContent = "content2";

        PostsUpdateRequestDto requestDto = PostsUpdateRequestDto.builder()
                .title(expectedTitle)
                .content(expectedContent)
                .build();

        String url = "http://localhost:" + port + "/api/v1/posts/" + updateId;

        HttpEntity<PostsUpdateRequestDto> requestEntity = new HttpEntity<>(requestDto);
        //when

        ResponseEntity<Long> responseEntity = restTemplate.exchange(url, HttpMethod.PUT, requestEntity, Long.class);

        //then

        assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(responseEntity.getBody()).isGreaterThan(0L);

        List<Posts> all = postsRepository.findAll();
        assertThat(all.get(0).getTitle()).isEqualTo(expectedTitle);
        assertThat(all.get(0).getContent()).isEqualTo(expectedContent);
        assertThat(all.get(0).getAuthor()).isEqualTo("author");
    }
```
* 실행 해보면 기존에 있는 데이터가 변경 되었음을 확인 할 수 있다.

### 3.5 웹에서 조회 기능 확인하기
* 현재 H2 DB는 메모리에서 실행되기 떄문에 직접 접근하려면 웹 콘솔을 사용해야한다.
* application.properties 에 다음과 같은 옵션을 추가한다.
> ```spring.h2.console.enabled=true```
* 스프링 메인 메서드를 실행후 ```localhost:8080/h2-console```로 접근한다.
* 이후 JDBC URL을 ```jdbc:h2:mem:testdb```로 변경후 접속한다.
* 다음으로 생성되어 있는 ```POSTS```테이블에 INSERT 쿼리를 실행시켜 데이터를 입력한다.
* 마지막으로 ```localhost:8080/api/v1/posts/1```로 접속하면 ```id = 1```인 게시글을 반환 받은 것을 확일 할 수 있다.

---
## 4. JPA Auditing으로 생성시간/수정시간 자동화 하기
* 보통 엔티티에는 해당 데이터의 ```생성시간```과 ```수정시간```을 포함한다.
* 언제 만들어졌고, 수정되었지는 유지보수에 있어 중요한 정보이기 때문이다.
* 따라서 매번 DB에 삽입 하기 전, 갱신하기전에 날짜 데이터를 등록/수정하는 코드가 여기저기 들어가게 된다
* 그런데 이러면 단순하고 반복적인 코드가 많아지고 귀찮고 지저분해진다.
* 이를 해결하기위해 JPA Auditing을 사용한다.

### 4.1 LocalDate 사용
* Java8 이전 Date와 Calender 클래스는 문제 있다. [자세한 내용](https://d2.naver.com/helloworld/645609)
> 참고. Java8 이전엔 ```Joda time```이라는 오픈소스로 문제점들을 피했다고 한다.
* 따라서, Java8부터 등장한 ```LocalDate```와 ```LocalDateTime```을 사용해야한다.


### 4.2 BaseTimeEntity 생성
* domain패키지에 생성한다.
```java
@Getter
@MappedSuperclass // JPA Entity 클래스들이 BaseTimeEntity를 상속할 경우 필드를도 칼럼으로 인식하도로 한다.
@EntityListeners(AuditingEntityListener.class) // Auditing 기능을 포함시킨다.
public class BaseTimeEntity {
    
    @CreatedDate // Entity가 생성되어 저장될 때 시간이 자동 저장된다.
    private LocalDateTime createDate;
    
    @LastModifiedDate // Entity의 값을 변경할 때 시간이 저장 된다.
    private LocalDateTime modifiedDate;
}
```

### 4.3 Posts 클래스에 상속하기
```java
public class Posts extends BaseTimeEntity{
    ...
}
```

### 4.4 JPA Auditing 어노테이션 활성화시키기
* Application 클래스 (메인 클래스)에 다음과 같은 어노테이션을 추가한다.
```java
// JPA Auditing 을 위한 어노테이션
@EnableJpaAuditing
... 생략 ...
public class Application {
    public static void main(String[] args){
        SpringApplication.run(Application.class, args);
    }
}
```
### 4.5 테스트
* PostsRepositoryTest에 다음와 같은 테스트를 추가한다.
```java
    @Test
    public void BaseTimeEntity_등록(){
        //given
        LocalDateTime now = LocalDateTime.of(2021,04,27,0,0);
        postsRepository.save(Posts.builder()
                .title("title")
                .content("content")
                .author("author")
                .build());
        //when
        List<Posts> postsList = postsRepository.findAll();
        //then

        Posts posts = postsList.get(0);
        System.out.println(">>>>>>>>> createDate = " + posts.getCreateDate() + ", modifiedDate = " + posts.getModifiedDate());

        assertThat(posts.getCreateDate()).isAfter(now);
        assertThat(posts.getModifiedDate()).isAfter(now);
    }
```
* 앞으로 등록일/수정일은 BaseTimeEntity를 상속 받기만 하면 해결 된다.